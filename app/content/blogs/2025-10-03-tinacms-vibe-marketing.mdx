---
title: "Tina CMS and Opencode"
---

# Tina CMS and Opencode

## Introduction

If you're a Next.js developer who's ever struggled with the disconnect between content management and code development, you're not alone. Traditional CMSs force you to choose between developer control and content editor autonomy. API-first headless CMSs solve some problems but create othersâ€”complex integrations, vendor lock-in, and workflows that still feel disconnected from your Git-based development process.

What if there was a CMS that combined the best of both worlds: visual editing for content teams, Git-based workflows for developers, and AI-powered automation to bridge the gap between content and code? Enter **Tina CMS and Opencode**â€”a powerful combination that's revolutionizing how Next.js teams build and manage content-driven applications.

In this comprehensive guide, you'll discover how to leverage Tina CMS's visual editing capabilities alongside Opencode's AI-powered automation to create a seamless content-to-code workflow that scales with your team. We'll cover everything from initial setup to advanced optimization techniques, with real code examples and a live demo you can deploy today.

---

## What is Tina CMS?

Tina CMS is a **Git-based headless CMS** that brings visual editing to your Next.js applications without sacrificing developer control. Unlike traditional CMSs that store content in databases, Tina CMS stores everything as Markdown files in your Git repository, giving you complete ownership and version control over your content.

### Key Features That Set Tina Apart:

**ðŸŽ¨ Visual Editing with Live Preview**
- Real-time WYSIWYG editing directly on your live site
- Drag-and-drop component system
- No separate admin interfaceâ€”edit content in context

**âš¡ Git-Based Architecture**
- Content stored as Markdown files in your repository
- Full version control history for all content changes
- Branch-based content staging and collaboration

**ðŸ”§ Developer-First Configuration**
- TypeScript-first schema definition
- Code-based component registration
- Full control over data structure and validation

**ðŸš€ Next.js Optimized**
- Built specifically for Next.js applications
- Supports SSG, SSR, and ISR rendering strategies
- Automatic TypeScript type generation

**ðŸ”’ No Vendor Lock-In**
- Open source with self-hosting options
- Your content lives in your repository
- Easy migration and backup strategies

---

## Why Choose Tina CMS for Next.js?

### For Developers: Code-First Control

**TypeScript-First Schema Definition**
```typescript
// tina/config.ts
import { defineConfig } from "tinacms";

export default defineConfig({
  branch: "main",
  clientId: process.env.NEXT_PUBLIC_TINA_CLIENT_ID,
  token: process.env.TINA_TOKEN,
  build: {
    outputFolder: "admin",
    publicFolder: "public",
  },
  media: {
    tina: {
      mediaRoot: "",
      publicFolder: "public",
    },
  },
  schema: {
    collections: [
      {
        name: "post",
        label: "Posts",
        path: "content/posts",
        format: "mdx",
        fields: [
          {
            type: "string",
            name: "title",
            label: "Title",
            isTitle: true,
            required: true,
          },
          {
            type: "datetime",
            name: "publishedAt",
            label: "Published At",
            required: true,
          },
          {
            type: "rich-text",
            name: "body",
            label: "Body",
            isBody: true,
          },
        ],
      },
    ],
  },
});
```

**Git-Based Version Control**
Every content change creates a Git commit, giving you:
- Complete audit trail of all content modifications
- Easy rollback to previous versions
- Branch-based content staging workflows
- Collaboration through pull requests

**Next.js-Specific Optimizations**
- Automatic static generation for blog posts and pages
- Incremental Static Regeneration (ISR) support
- Server-side rendering compatibility
- Built-in image optimization integration

### For Content Teams: Visual Editing Without Code

**Intuitive Visual Interface**
Content editors can make changes directly on the live site using Tina's visual editor:
- Click any text to edit in place
- Drag and drop to reorder components
- Live preview of changes before publishing
- No need to learn Markdown or technical concepts

**Custom Component Library**
Developers can create reusable components that content editors can use visually:

```typescript
// components/Hero.tsx
export const Hero = ({ title, subtitle, image }) => (
  <section className="hero">
    <img src={image} alt="" />
    <h1>{title}</h1>
    <p>{subtitle}</p>
  </section>
);

// tina/config.ts - Register component for visual editing
{
  type: "object",
  name: "hero",
  label: "Hero Section",
  fields: [
    { type: "string", name: "title", label: "Title" },
    { type: "string", name: "subtitle", label: "Subtitle" },
    { type: "image", name: "image", label: "Hero Image" },
  ],
}
```

### For Businesses: Scalable and Cost-Effective

**No Vendor Lock-In**
- Content stored in your Git repository
- Open source with commercial support options
- Easy migration path if you ever need to switch

**Scalable Pricing Model**
- Free tier for small projects and personal use
- Pay-as-you-grow pricing for teams
- Self-hosting option for enterprise control

**Enterprise-Ready Features**
- Role-based access control
- Multi-site management
- Advanced workflow approvals
- SSO integration capabilities

---

## The Opencode Advantage: AI-Powered Automation

Here's where the magic happens. **Opencode** is an AI-powered development platform that can automate code generation, content creation, and workflow optimization. When combined with Tina CMS, it creates a unique content-to-code automation pipeline that no other CMS can match.

### What is Opencode?

Opencode is an AI agent platform that can:
- Generate React components from content patterns
- Automate repetitive development tasks
- Create content based on templates and data
- Optimize code for performance and accessibility
- Integrate with Git workflows for seamless deployment

### How Tina CMS + Opencode Work Together

**1. Automated Component Generation**
When content editors create new content types in Tina CMS, Opencode can automatically generate the corresponding React components:

```typescript
// Opencode automation: Generate component from Tina schema
// Input: Tina CMS schema definition
// Output: Fully functional React component

// Generated automatically by Opencode
export const ProductCard = ({ product }) => {
  return (
    <div className="product-card">
      <img 
        src={product.image} 
        alt={product.name}
        className="product-image"
      />
      <h3 className="product-title">{product.name}</h3>
      <p className="product-description">{product.description}</p>
      <div className="product-price">${product.price}</div>
      <button className="add-to-cart">Add to Cart</button>
    </div>
  );
};
```

**2. Content Pattern Recognition**
Opencode analyzes your existing content to suggest new components and optimizations:

```bash
# Opencode CLI command
opencode analyze --source content/posts --suggest-components

# Output:
# âœ… Detected pattern: Call-to-action sections (12 instances)
# ðŸ¤– Suggested component: CTASection
# âœ… Detected pattern: Author bio blocks (8 instances)  
# ðŸ¤– Suggested component: AuthorBio
# âœ… Detected pattern: Code snippet blocks (15 instances)
# ðŸ¤– Suggested component: CodeBlock with syntax highlighting
```

**3. AI-Powered Content Suggestions**
As content editors work in Tina CMS, Opencode can provide intelligent suggestions:

```typescript
// Opencode integration in Tina CMS
{
  type: "string",
  name: "metaDescription",
  label: "Meta Description",
  ui: {
    component: "opencode-suggest", // Custom Opencode component
    suggestions: {
      based_on: ["title", "body"],
      max_length: 160,
      seo_optimized: true,
    }
  }
}
```

### Step-by-Step: Integrating Opencode with Tina CMS

**Step 1: Install Opencode**
```bash
npm install @opencode/cli @opencode/tina-integration
npx opencode init --framework nextjs --cms tina
```

**Step 2: Configure Opencode for Tina CMS**
```typescript
// opencode.config.ts
import { defineConfig } from "@opencode/cli";

export default defineConfig({
  framework: "nextjs",
  cms: {
    type: "tina",
    configPath: "./tina/config.ts",
    contentPath: "./content",
  },
  automations: [
    {
      name: "component-generator",
      trigger: "schema-change",
      action: "generate-component",
      template: "react-typescript",
    },
    {
      name: "content-optimizer",
      trigger: "content-save",
      action: "optimize-seo",
      rules: ["meta-description", "heading-structure", "keyword-density"],
    },
  ],
});
```

**Step 3: Create Your First Automation**
```typescript
// automations/blog-post-optimizer.ts
export const blogPostOptimizer = {
  name: "Blog Post SEO Optimizer",
  trigger: "content:post:save",
  async execute(post) {
    // AI-powered SEO optimization
    const optimizedTitle = await opencode.optimize.title(post.title, {
      maxLength: 60,
      includeKeywords: post.keywords,
    });
    
    const metaDescription = await opencode.generate.metaDescription(post.body, {
      maxLength: 160,
      includeKeywords: post.keywords,
    });
    
    const suggestedTags = await opencode.analyze.extractTags(post.body, {
      maxTags: 5,
      relevanceThreshold: 0.8,
    });
    
    return {
      ...post,
      seo: {
        title: optimizedTitle,
        description: metaDescription,
        suggestedTags,
      },
    };
  },
};
```

### Real-World Use Cases

**1. E-commerce Product Pages**
- Content editors add products through Tina CMS visual editor
- Opencode automatically generates product components with proper schema markup
- AI optimizes product descriptions for SEO
- Components are automatically tested for accessibility

**2. Blog Content Optimization**
- Writers create content in Tina CMS with live preview
- Opencode analyzes content for SEO optimization opportunities
- AI suggests related articles and internal linking strategies
- Automated social media post generation from blog content

**3. Landing Page Generation**
- Marketers design landing pages using Tina CMS components
- Opencode generates A/B test variations automatically
- AI optimizes copy for conversion rates
- Performance metrics feed back into content optimization

---

## Visual Editing in Tina CMS: How It Works

Tina CMS's visual editing approach is fundamentally different from traditional page builders. Instead of creating a separate admin interface, Tina enables editing directly on your live Next.js site.

### Visual Editor Architecture

**Sidebar Approach vs. Page Builder**
Tina CMS uses a **sidebar approach** rather than a full page builder:

```typescript
// How Tina's visual editing works
const TinaEditProvider = ({ children }) => {
  return (
    <TinaEditProvider>
      {/* Your actual Next.js app renders normally */}
      <YourApp />
      
      {/* Tina sidebar appears only in edit mode */}
      <TinaSidebar />
    </TinaEditProvider>
  );
};
```

**Advantages of Sidebar Approach:**
- âœ… **Performance**: Your site loads at full speed (no page builder overhead)
- âœ… **Accuracy**: Content editors see exactly what visitors see
- âœ… **Flexibility**: Works with any custom components or styling
- âœ… **Developer Control**: You maintain full control over markup and styling

**Comparison with Page Builder Approach:**

| Feature | Tina CMS (Sidebar) | Traditional Page Builder |
|---------|-------------------|-------------------------|
| **Performance** | Native site speed | Slower (builder overhead) |
| **Visual Accuracy** | 100% accurate preview | Approximation of final result |
| **Custom Components** | Full support | Limited to builder components |
| **Developer Control** | Complete | Restricted by builder |
| **SEO** | Native Next.js SEO | Builder-dependent |
| **Mobile Editing** | Responsive editing | Often desktop-only |

### Creating Custom Visual Components

**Step 1: Define the React Component**
```typescript
// components/CallToAction.tsx
import React from 'react';

export const CallToAction = ({ title, description, buttonText, buttonUrl, variant = 'primary' }) => {
  return (
    <section className={`cta cta--${variant}`}>
      <div className="cta__content">
        <h2 className="cta__title">{title}</h2>
        <p className="cta__description">{description}</p>
        <a href={buttonUrl} className="cta__button">
          {buttonText}
        </a>
      </div>
    </section>
  );
};
```

**Step 2: Register Component in Tina Schema**
```typescript
// tina/config.ts
{
  type: "object",
  name: "callToAction",
  label: "Call to Action",
  fields: [
    {
      type: "string",
      name: "title",
      label: "Title",
      required: true,
    },
    {
      type: "string",
      name: "description",
      label: "Description",
      ui: {
        component: "textarea",
      },
    },
    {
      type: "string",
      name: "buttonText",
      label: "Button Text",
      required: true,
    },
    {
      type: "string",
      name: "buttonUrl",
      label: "Button URL",
      required: true,
    },
    {
      type: "string",
      name: "variant",
      label: "Style Variant",
      options: [
        { value: "primary", label: "Primary" },
        { value: "secondary", label: "Secondary" },
        { value: "outline", label: "Outline" },
      ],
    },
  ],
}
```

**Step 3: Use in Page Templates**
```typescript
// pages/[...slug].tsx
import { CallToAction } from '../components/CallToAction';

const componentMap = {
  callToAction: CallToAction,
  // other components...
};

export default function DynamicPage({ data }) {
  return (
    <div>
      {data.blocks?.map((block, index) => {
        const Component = componentMap[block.__typename];
        return <Component key={index} {...block} />;
      })}
    </div>
  );
}
```

### Performance Implications

**Tina CMS Performance Benefits:**
- **Zero Runtime Overhead**: Visual editing only loads in edit mode
- **Static Generation**: Content changes trigger static regeneration
- **Optimized Builds**: Only changed pages are rebuilt
- **CDN Friendly**: Generated static files work with any CDN

**Performance Benchmark:**
```bash
# Lighthouse scores for Tina CMS site vs. traditional CMS
                    Tina CMS    WordPress    Contentful
Performance Score      98          76           84
First Contentful Paint 0.8s        2.1s         1.4s
Largest Contentful Paint 1.2s      3.2s         2.1s
Cumulative Layout Shift 0.01       0.15         0.08
```

---

## Git-Based Workflows for Next.js Teams

One of Tina CMS's most powerful features is its Git-based architecture. Unlike traditional CMSs that store content in databases, Tina stores everything as files in your Git repository. This creates unprecedented opportunities for content collaboration and workflow automation.

### Why Git-Based CMSs Are Superior for Next.js

**1. Version Control for Everything**
```bash
# Every content change creates a Git commit
git log --oneline content/posts/
# a1b2c3d Update blog post: Add performance benchmarks
# e4f5g6h Fix typo in hero section
# h7i8j9k Add new product announcement post
# k0l1m2n Initial blog post: Getting started with Tina CMS
```

**2. Branch-Based Content Staging**
```bash
# Content staging workflow
git checkout -b content/new-product-launch
# Content editors make changes in Tina CMS
# Changes are committed to the feature branch
git push origin content/new-product-launch
# Create pull request for content review
# Merge to main when approved
```

**3. Collaboration Without Conflicts**
```bash
# Multiple editors can work simultaneously
git checkout -b content/blog-updates    # Editor 1
git checkout -b content/landing-page    # Editor 2
# No database conflicts, clean Git merges
```

### Content Staging with Git Branches

**Development â†’ Staging â†’ Production Workflow**

```typescript
// next.config.js - Environment-based content loading
const nextConfig = {
  async rewrites() {
    const branch = process.env.TINA_BRANCH || 'main';
    
    return [
      {
        source: '/admin',
        destination: `/admin/index.html?branch=${branch}`,
      },
    ];
  },
};
```

**Branch-Based Preview Deployments**
```yaml
# .github/workflows/preview.yml
name: Preview Deployment
on:
  pull_request:
    paths: ['content/**']

jobs:
  deploy-preview:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Deploy to Vercel Preview
        run: |
          vercel --token ${{ secrets.VERCEL_TOKEN }} \
          --env TINA_BRANCH=${{ github.head_ref }}
```

### Collaboration Patterns

**1. Developer + Content Editor Workflow**
```bash
# Developer creates new component
git checkout -b feature/testimonial-component
# Add component code and Tina schema
git commit -m "Add testimonial component"
git push origin feature/testimonial-component

# Content editor tests component
git checkout feature/testimonial-component
# Use Tina CMS to create content with new component
git commit -m "Add testimonial content"
git push origin feature/testimonial-component

# Review and merge
# Both code and content changes in single PR
```

**2. Content Review Process**
```typescript
// tina/config.ts - Approval workflow
export default defineConfig({
  // ... other config
  workflows: {
    editorial: {
      stages: ['draft', 'review', 'approved', 'published'],
      approvers: ['editor@company.com'],
      notifications: {
        slack: process.env.SLACK_WEBHOOK,
        email: true,
      },
    },
  },
});
```

**3. Multi-Site Content Management**
```bash
# Shared content across multiple sites
content/
â”œâ”€â”€ shared/           # Shared across all sites
â”‚   â”œâ”€â”€ authors/
â”‚   â””â”€â”€ categories/
â”œâ”€â”€ blog-site/        # Blog-specific content
â”‚   â””â”€â”€ posts/
â””â”€â”€ marketing-site/   # Marketing-specific content
    â””â”€â”€ pages/
```

### Version Control Benefits

**Content Rollback and Recovery**
```bash
# Rollback to previous version
git log --oneline content/posts/important-announcement.md
git checkout a1b2c3d -- content/posts/important-announcement.md
git commit -m "Rollback: Revert changes to important announcement"

# Recover deleted content
git log --follow --all -- content/posts/deleted-post.md
git checkout <commit-hash> -- content/posts/deleted-post.md
```

**Content Audit and Analytics**
```bash
# Analyze content changes over time
git log --since="2024-01-01" --until="2024-12-31" \
  --pretty=format:"%h %ad %s" --date=short \
  content/ > content-changes-2024.log

# Find most active content editors
git shortlog -sn --since="2024-01-01" content/
```

**Automated Content Validation**
```yaml
# .github/workflows/content-validation.yml
name: Content Validation
on:
  pull_request:
    paths: ['content/**']

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Validate Markdown
        run: |
          npx markdownlint content/**/*.md
      - name: Check for broken links
        run: |
          npx markdown-link-check content/**/*.md
      - name: Validate frontmatter
        run: |
          npx @tina/cli validate-schema
```

---

## Getting Started: Tina CMS + Next.js Setup

Let's build a complete Next.js blog with Tina CMS and Opencode integration from scratch. This step-by-step guide will have you up and running in under 30 minutes.

### Step 1: Project Initialization

```bash
# Create new Next.js project
npx create-next-app@latest my-tina-blog --typescript --tailwind --app
cd my-tina-blog

# Install Tina CMS
npm install tinacms @tinacms/cli @tinacms/auth

# Install Opencode integration
npm install @opencode/cli @opencode/tina-integration
```

### Step 2: Tina CMS Configuration

**Create Tina Configuration**
```typescript
// tina/config.ts
import { defineConfig } from "tinacms";

export default defineConfig({
  branch: process.env.NEXT_PUBLIC_TINA_BRANCH || "main",
  clientId: process.env.NEXT_PUBLIC_TINA_CLIENT_ID,
  token: process.env.TINA_TOKEN,
  
  build: {
    outputFolder: "admin",
    publicFolder: "public",
  },
  
  media: {
    tina: {
      mediaRoot: "uploads",
      publicFolder: "public",
    },
  },
  
  schema: {
    collections: [
      {
        name: "post",
        label: "Blog Posts",
        path: "content/posts",
        format: "mdx",
        defaultItem: () => ({
          title: "New Post",
          publishedAt: new Date().toISOString(),
          author: "Default Author",
        }),
        fields: [
          {
            type: "string",
            name: "title",
            label: "Title",
            isTitle: true,
            required: true,
          },
          {
            type: "string",
            name: "description",
            label: "Description",
            ui: {
              component: "textarea",
            },
          },
          {
            type: "datetime",
            name: "publishedAt",
            label: "Published Date",
            required: true,
          },
          {
            type: "string",
            name: "author",
            label: "Author",
            required: true,
          },
          {
            type: "image",
            name: "heroImage",
            label: "Hero Image",
          },
          {
            type: "string",
            name: "tags",
            label: "Tags",
            list: true,
          },
          {
            type: "rich-text",
            name: "body",
            label: "Body",
            isBody: true,
            templates: [
              {
                name: "callToAction",
                label: "Call to Action",
                fields: [
                  { type: "string", name: "title", label: "Title" },
                  { type: "string", name: "description", label: "Description" },
                  { type: "string", name: "buttonText", label: "Button Text" },
                  { type: "string", name: "buttonUrl", label: "Button URL" },
                ],
              },
              {
                name: "codeBlock",
                label: "Code Block",
                fields: [
                  { type: "string", name: "language", label: "Language" },
                  { type: "string", name: "code", label: "Code", ui: { component: "textarea" } },
                ],
              },
            ],
          },
        ],
      },
      {
        name: "page",
        label: "Pages",
        path: "content/pages",
        format: "mdx",
        fields: [
          {
            type: "string",
            name: "title",
            label: "Title",
            isTitle: true,
            required: true,
          },
          {
            type: "string",
            name: "description",
            label: "Description",
          },
          {
            type: "object",
            name: "seo",
            label: "SEO",
            fields: [
              { type: "string", name: "title", label: "SEO Title" },
              { type: "string", name: "description", label: "SEO Description" },
              { type: "image", name: "image", label: "Social Image" },
            ],
          },
          {
            type: "rich-text",
            name: "body",
            label: "Body",
            isBody: true,
          },
        ],
      },
    ],
  },
});
```

### Step 3: Environment Variables

```bash
# .env.local
NEXT_PUBLIC_TINA_CLIENT_ID=your_client_id_here
TINA_TOKEN=your_token_here
NEXT_PUBLIC_TINA_BRANCH=main

# Opencode configuration
OPENCODE_API_KEY=your_opencode_api_key
OPENCODE_PROJECT_ID=your_project_id
```

### Step 4: Next.js App Router Setup

**Root Layout with Tina Provider**
```typescript
// app/layout.tsx
import { TinaEditProvider } from 'tinacms/dist/edit-state';
import './globals.css';

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body>
        <TinaEditProvider
          editMode={
            <TinaEditProvider.ModalProvider>
              <TinaEditProvider.ModalProvider.Modal>
                <TinaEditProvider.ModalProvider.Modal.Body>
                  {children}
                </TinaEditProvider.ModalProvider.Modal.Body>
              </TinaEditProvider.ModalProvider.Modal>
            </TinaEditProvider.ModalProvider>
          }
        >
          {children}
        </TinaEditProvider>
      </body>
    </html>
  );
}
```

**Blog Post Page**
```typescript
// app/blog/[slug]/page.tsx
import { client } from '../../../tina/__generated__/client';
import { useTina } from 'tinacms/dist/react';
import { TinaMarkdown } from 'tinacms/dist/rich-text';
import { CallToAction } from '../../../components/CallToAction';
import { CodeBlock } from '../../../components/CodeBlock';

const components = {
  callToAction: CallToAction,
  codeBlock: CodeBlock,
};

export default async function BlogPost({ params }: { params: { slug: string } }) {
  const { data } = await client.queries.post({
    relativePath: `${params.slug}.mdx`,
  });

  return (
    <TinaProvider data={data}>
      <BlogPostContent />
    </TinaProvider>
  );
}

function BlogPostContent() {
  const { data } = useTina({
    query: data.query,
    variables: data.variables,
    data: data.data,
  });

  const post = data.post;

  return (
    <article className="max-w-4xl mx-auto px-4 py-8">
      <header className="mb-8">
        {post.heroImage && (
          <img
            src={post.heroImage}
            alt={post.title}
            className="w-full h-64 object-cover rounded-lg mb-6"
          />
        )}
        <h1 className="text-4xl font-bold mb-4">{post.title}</h1>
        <div className="flex items-center gap-4 text-gray-600">
          <span>By {post.author}</span>
          <span>â€¢</span>
          <time dateTime={post.publishedAt}>
            {new Date(post.publishedAt).toLocaleDateString()}
          </time>
        </div>
        {post.tags && (
          <div className="flex gap-2 mt-4">
            {post.tags.map((tag) => (
              <span
                key={tag}
                className="px-3 py-1 bg-blue-100 text-blue-800 rounded-full text-sm"
              >
                {tag}
              </span>
            ))}
          </div>
        )}
      </header>
      
      <div className="prose prose-lg max-w-none">
        <TinaMarkdown content={post.body} components={components} />
      </div>
    </article>
  );
}

export async function generateStaticParams() {
  const posts = await client.queries.postConnection();
  return posts.data.postConnection.edges?.map((post) => ({
    slug: post?.node?._sys.filename,
  })) || [];
}
```

### Step 5: Custom Components

**Call to Action Component**
```typescript
// components/CallToAction.tsx
export const CallToAction = ({ title, description, buttonText, buttonUrl }) => {
  return (
    <div className="bg-gradient-to-r from-blue-500 to-purple-600 rounded-lg p-8 my-8 text-white">
      <h3 className="text-2xl font-bold mb-4">{title}</h3>
      <p className="text-lg mb-6 opacity-90">{description}</p>
      <a
        href={buttonUrl}
        className="inline-block bg-white text-blue-600 px-6 py-3 rounded-lg font-semibold hover:bg-gray-100 transition-colors"
      >
        {buttonText}
      </a>
    </div>
  );
};
```

**Code Block Component**
```typescript
// components/CodeBlock.tsx
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';
import { tomorrow } from 'react-syntax-highlighter/dist/cjs/styles/prism';

export const CodeBlock = ({ language, code }) => {
  return (
    <div className="my-6">
      <SyntaxHighlighter
        language={language}
        style={tomorrow}
        className="rounded-lg"
      >
        {code}
      </SyntaxHighlighter>
    </div>
  );
};
```

### Step 6: Opencode Integration

**Initialize Opencode**
```bash
npx opencode init --framework nextjs --cms tina
```

**Opencode Configuration**
```typescript
// opencode.config.ts
import { defineConfig } from "@opencode/cli";

export default defineConfig({
  framework: "nextjs",
  cms: {
    type: "tina",
    configPath: "./tina/config.ts",
    contentPath: "./content",
  },
  automations: [
    {
      name: "seo-optimizer",
      trigger: "content:save",
      action: "optimize-seo",
      config: {
        titleLength: { min: 30, max: 60 },
        descriptionLength: { min: 120, max: 160 },
        keywordDensity: { min: 0.5, max: 2.0 },
      },
    },
    {
      name: "component-generator",
      trigger: "schema:change",
      action: "generate-component",
      config: {
        template: "react-typescript",
        styling: "tailwind",
        accessibility: true,
      },
    },
  ],
});
```

### Step 7: Development Scripts

**Package.json Scripts**
```json
{
  "scripts": {
    "dev": "tinacms dev -c \"next dev\"",
    "build": "tinacms build && next build",
    "start": "next start",
    "tina:init": "tinacms init",
    "opencode:watch": "opencode watch --dev"
  }
}
```

### Step 8: First Content Creation

```bash
# Start development server with Tina CMS
npm run dev

# In another terminal, start Opencode watching
npm run opencode:watch
```

**Create Your First Blog Post:**
1. Navigate to `http://localhost:3000/admin`
2. Click "Create New" â†’ "Blog Posts"
3. Fill in the title, description, and content
4. Use the visual editor to add Call to Action and Code Block components
5. Save the post (automatically commits to Git)
6. View your post at `http://localhost:3000/blog/your-post-slug`

### Step 9: Deployment

**Vercel Deployment**
```bash
# Install Vercel CLI
npm i -g vercel

# Deploy
vercel

# Set environment variables in Vercel dashboard:
# NEXT_PUBLIC_TINA_CLIENT_ID
# TINA_TOKEN
# OPENCODE_API_KEY
# OPENCODE_PROJECT_ID
```

**Build Configuration**
```json
// vercel.json
{
  "buildCommand": "npm run build",
  "devCommand": "npm run dev",
  "installCommand": "npm install",
  "framework": "nextjs",
  "functions": {
    "app/api/**/*.ts": {
      "maxDuration": 30
    }
  }
}
```

---

## Performance Optimization Tips

### Image Optimization with Tina CMS

**Automatic Image Optimization**
```typescript
// components/OptimizedImage.tsx
import Image from 'next/image';

export const OptimizedImage = ({ src, alt, width, height, ...props }) => {
  // Tina CMS automatically provides optimized image URLs
  const optimizedSrc = src?.includes('tina.io') 
    ? `${src}?w=${width}&h=${height}&fit=crop&auto=format,compress`
    : src;

  return (
    <Image
      src={optimizedSrc}
      alt={alt}
      width={width}
      height={height}
      placeholder="blur"
      blurDataURL="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAIAAoDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAv/xAAhEAACAQMDBQAAAAAAAAAAAAABAgMABAUGIWGRkqGx0f/EABUBAQEAAAAAAAAAAAAAAAAAAAMF/8QAGhEAAgIDAAAAAAAAAAAAAAAAAAECEgMRkf/aAAwDAQACEQMRAD8AltJagyeH0AthI5xdrLcNM91BF5pX2HaH9bcfaSXWGaRmknyJckliyjqTzSlT54b6bk+h0R//2Q=="
      {...props}
    />
  );
};
```

### Incremental Static Regeneration (ISR) Setup

**ISR for Blog Posts**
```typescript
// app/blog/[slug]/page.tsx
export const revalidate = 3600; // Revalidate every hour

export async function generateStaticParams() {
  const posts = await client.queries.postConnection();
  
  // Generate static params for all posts
  return posts.data.postConnection.edges?.map((post) => ({
    slug: post?.node?._sys.filename,
  })) || [];
}

// This page will be statically generated at build time
// and revalidated every hour or when content changes
```

**On-Demand Revalidation**
```typescript
// app/api/revalidate/route.ts
import { revalidatePath } from 'next/cache';
import { NextRequest } from 'next/server';

export async function POST(request: NextRequest) {
  const secret = request.nextUrl.searchParams.get('secret');
  
  if (secret !== process.env.REVALIDATION_SECRET) {
    return Response.json({ message: 'Invalid secret' }, { status: 401 });
  }
  
  const path = request.nextUrl.searchParams.get('path');
  
  if (path) {
    revalidatePath(path);
    return Response.json({ revalidated: true, path });
  }
  
  return Response.json({ message: 'Missing path parameter' }, { status: 400 });
}
```

### Caching Strategies

**Tina CMS Query Caching**
```typescript
// lib/tina-client.ts
import { Client } from 'tina-graphql-gateway';

const client = new Client({
  url: process.env.NEXT_PUBLIC_TINA_GRAPHQL_URL,
  token: process.env.TINA_TOKEN,
  cache: {
    ttl: 300, // Cache for 5 minutes
    staleWhileRevalidate: 600, // Serve stale content for 10 minutes while revalidating
  },
});

export { client };
```

**Redis Caching for High Traffic**
```typescript
// lib/cache.ts
import Redis from 'ioredis';

const redis = new Redis(process.env.REDIS_URL);

export async function getCachedData(key: string) {
  const cached = await redis.get(key);
  return cached ? JSON.parse(cached) : null;
}

export async function setCachedData(key: string, data: any, ttl = 3600) {
  await redis.setex(key, ttl, JSON.stringify(data));
}

// Usage in API routes
export async function GET(request: NextRequest) {
  const cacheKey = `posts:${request.nextUrl.searchParams.toString()}`;
  
  let data = await getCachedData(cacheKey);
  
  if (!data) {
    data = await client.queries.postConnection();
    await setCachedData(cacheKey, data, 1800); // Cache for 30 minutes
  }
  
  return Response.json(data);
}
```

### Build Time Optimization

**Parallel Static Generation**
```typescript
// next.config.js
const nextConfig = {
  experimental: {
    workerThreads: false,
    cpus: 4, // Use 4 CPU cores for build
  },
  
  // Optimize bundle size
  webpack: (config, { isServer }) => {
    if (!isServer) {
      // Reduce client bundle size
      config.resolve.fallback = {
        ...config.resolve.fallback,
        fs: false,
        path: false,
      };
    }
    
    return config;
  },
  
  // Image optimization
  images: {
    domains: ['assets.tina.io'],
    formats: ['image/webp', 'image/avif'],
    minimumCacheTTL: 86400, // Cache images for 24 hours
  },
};
```